#' Create probability distribution of combinations of elements in the data
#'
#' Take dataset and report observed and expected likelihood that elements and
#' combinations of elements occur in this dataset, and whether this differs
#' from a null condition
#'
#' @param data matrix with one column per element, and one row per event,
#'        consisting of 1 (element was active during that event) and 0 (element
#'        was not active)
#' @param condition character vector of same length as 'data' that contains
#'        information on the condition each event belongs to, so probabilities
#'        can be compared across conditions; if NULL, all events will be tested
#'        against a random null condition based on permutations
#' @param test.condition level of 'condition' that is supposed to be tested
#' @param null.condition level of 'condition' that is used to create the null
#'        distribution of values; if NULL, all levels that are not the test
#'        condition will be used
#' @param duration numeric vector that contains information on the duration of
#'        each event; if NULL, all events are assumed to have equal duration
#' @param ran.trials Number of randomisations that will be performed to find the
#'        null distribution
#' @param random.level character vector of the level on which the randomization
#'        should take place. If NULL, the randomization takes place on the event
#'        level (i.e., every row can either be selected or not); if a vector is
#'        provided, the randomization takes place on the levels of that vector
#'        rather than individual events
#' @param control list of vectors that are used as control variables. During
#'        bootstraps, the ratio of events in each level will be adapted. So, for
#'        example, if in the test distribution, there are three angry
#'        participants for each happy participant, the null distribution will
#'        maintain that ratio
#' @param combination.size if not all combinations of elements are of interest
#'        (e.g., if the question only concerns single elements or dyads of
#'        elements), this variable allows to reduce the results to those
#'        combinations, increasing speed
#' @param tail either 'two-tailed' (proportion of null probabilities that are more
#'         extreme than the observed value), 'right' (proportion of null probabilities
#'         that are larger than observed probabilities), or 'left' (proportion of null
#'         probabilities that are smaller than observed probabilities); default is 'two-tailed'
#' @param use_parallel logical, should the bootstrap be parallelized (default is
#'        \code{TRUE})
#' @param n_cores numeric, the number cores to be used for parallelization.
#'        Default is the number of available cores minus 1. The argument is
#'        ignored if \code{use_cluster = FALSE}.
#'
#' @details Expected values are based on bootstraps of null distribution, so the
#' values represent distribution of element co-occurrence under null condition;
#' or permutations of the observed distribution to test it against 'random'.
#'
#' The resulting object is the basis for most other functions in this package.
#'
#' @return Function returns a Result dataframe that includes the combination name, how many elements it consisted of, how often it was observed, the probability it was observed under this condition, the expected probability under null condition (based on the permutation or bootstrap), the z value (standard deviations from the mean of the randomisations), p-value (how many randomisations were more extreme), and for direct comparisons of contexts the specificity (probability that the condition is in fact the test condition if that combination is known) and probability increase (the factor by which the probability of the element is higher in the test than null condition)
#' @return 'event.size.information' contains information about the observed and expected size of combination or elements per event based on the randomisations
#'
#' @importFrom stats sd
#' @importFrom picante randomizeMatrix
#' @importFrom parallel parLapply
#' @importFrom parallel mclapply
#' @importFrom parallel makeCluster
#' @importFrom parallel detectCores
#' @importFrom parallel clusterExport
#' @importFrom parallel stopCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom Rfast rowsums rowmeans Table
#' @importFrom compiler cmpfun
#'
#'
#' @author Alexander Mielke
#' @export
#'
#' @examples
#' ### how do angry facial expressions differ from non-angry ones?
#' data(emotions_set)
#' angry.face <- netfacs(data = emotions_set[[1]],
#'                       condition = emotions_set[[2]]$emotion,
#'                       test.condition = "anger",
#'                       null.condition = NULL,
#'                       duration = NULL,
#'                       ran.trials = 100,
#'                       control = NULL,
#'                       random.level = NULL,
#'                       combination.size = 2,
#'                       tail = 'two-tailed',
#'                       use_parallel = TRUE,
#'                       n_cores = 2)
#'
#' head(angry.face$result, 20)
#' angry.face$event.size.information



netfacs <- function(data,
                    condition = NULL,
                    test.condition = NULL,
                    null.condition = NULL,
                    duration = NULL,
                    ran.trials = 1000,
                    control = NULL,
                    random.level = NULL,
                    combination.size = 2,
                    tail = 'two-tailed',
                    use_parallel = TRUE,
                    n_cores = 2) {

  # set the function for the rules generation
  rules_foo <- cmpfun(create_rule_set3)

  # fix column names of dataset to not include special characters or spaces
  colnames(data) = gsub(colnames(data), pattern = ' ', replacement = '', fixed = TRUE)
  colnames(data) = gsub(colnames(data), pattern = '+', replacement = '', fixed = TRUE)
  colnames(data) = gsub(colnames(data), pattern = '_', replacement = '', fixed = TRUE)
  colnames(data) = gsub(colnames(data), pattern = '.', replacement = '', fixed = TRUE)

  # determine number of cores for parallelization
  if (isTRUE(use_parallel) & is.null(n_cores)) {
    n_cores = detectCores()-1
  }
  if (isFALSE(use_parallel) & is.null(n_cores)) {
    n_cores = 1
  }
  if (n_cores <= 1) {
    use_parallel <- FALSE
  }
  if (ran.trials <= 100) {
    use_parallel <- FALSE
  }

  # if combination.size is not determined, the maximum combination size that is considered is set to the maximum observed combination size
  if(is.null(combination.size)){combination.size = max(rowsums(data))}

  # data preparation happens for two different cases: either 'condition' is set, in which case the 'test.condition' is tested against all other cases or against one specific 'null.condition'; alternatively, if no condition is set, the probabilities are compared with random probabilities
  if(!is.null(condition)){

    # Error messages in case test.condition is wrongly specified
    if(is.null(test.condition)){return(print('Error: specify test condition'))}
    if(!test.condition%in%condition){return(print('Test condition not part of the condition vector'))}

    # if random.level is not defined, each event/row is its own case, and all events are compared against each other. If random.level is defined, the randomization will select cases based on which level they belong to
    if(is.null(random.level)){random.level = 1:nrow(data)}

    # if the null condition is not determined, all cases that are not part of the test dataset are classed as null condition
    condition.x=as.character(condition)
    if(is.null(null.condition)){
      null.condition = 'all'
      condition.x[condition.x!=test.condition] = 'all'
      }

    # the control argument, which is entered as a list (to allow for multiple control variables) is turned into a combination of those variables. E.g., if you control for sex and social group, then each individual or is classed as sex_group
    if(length(control)>1){
      control.obj=apply(do.call(cbind, control), 1, function(k) paste(k, collapse = '_'))
    }
    if(length(control)==1){
      control.obj=unlist(control[1])
    }
    if(is.null(control)){
      control.obj=rep(1, nrow(data))
    }

    # if duration is set, all variable vectors have to be multiplied accordingly
    if(is.null(duration)){min.duration = 1}
    if(!is.null(duration)){
      min.duration = min(duration)
      duration = round(duration/min.duration, 0) # duration is determined by the minimum value. So, if the shortest event is 0.05s, then an even of 1sec will be represented 20 times
      data <- data[rep(1:nrow(data), times = duration), ]

      condition.x <- condition.x[rep(1:length(condition.x), times = duration)]
      control.obj <- control.obj[rep(1:length(control.obj), times = duration)]
      random.level <- random.level[rep(1:length(random.level), times = duration)]
    }

    ### turn data into test data and null data
    data.test=data[condition.x==test.condition,]
    data.null=data[condition.x==null.condition,]

    #turn control variable into test and null control variable
    test.control = control.obj[condition.x==test.condition]
    null.control = control.obj[condition.x==null.condition]

    #turn random level variable into test and null control variable
    random.level.null = random.level[condition.x==null.condition]
    random.level.test = random.level[condition.x==test.condition]

    #create ratio for randomisation of null dataset: if the test dataset contains 12 males and 15 females (ratio of 1.25), then the selection of the null dataset should reflect this
    rl.test.ratio = Table(test.control[!duplicated(random.level.test)])
    rl.test.ratio = rl.test.ratio/sum(rl.test.ratio) # ratio for test data

    rl.null.ratio = data.frame(subj = random.level.null[!duplicated(random.level.null)],
                                  control = null.control[!duplicated(random.level.null)])
    rl.null.ratio$llh = as.numeric(rl.test.ratio[match(rl.null.ratio$control, names(rl.test.ratio))])


    # create probabilities for null dataset
    elements.null = lapply(1:nrow(data.null), function(x){ # create a list for each event/row of the null dataset, containing the names of the elements that were active
      xx = colnames(data.null)[data.null[x,]==1]
    })
    rs.null = rules_foo(elements = elements.null, maxlen = combination.size) # this function takes the elements.null list, gives it over to create_rule_set, which is used to extract the probabilities for each combination
    rs.null$combination.size = unlist(lapply(strsplit(as.character(rs.null$combination), "_", fixed = T),
                                             length), FALSE, FALSE)


    # for single units that are not active during this specific condition, add them anyways with the information that they did not show up
    single.units = do.call(rbind, lapply(colnames(data), function(x){
      yy = rs.null[1,]
      yy$observed.probability = 0
      yy$count = 0
      yy$combination.size = 1
      yy$combination = x
      return(yy)
    }))

    if(nrow(single.units[!single.units$combination%in%rs.null$combination,])>0){
      rs.null = rbind(single.units[!single.units$combination%in%rs.null$combination,], rs.null)
    }

    # create probabilities for test dataset, using the same method as above
    elements.test = lapply(1:nrow(data.test), function(x){
      xx = colnames(data.test)[data.test[x,]==1]
    })
    rs.test <- rules_foo(elements = elements.test, maxlen = combination.size)
    rs.test$combination.size = unlist(lapply(strsplit(as.character(rs.test$combination), "_", fixed = T),
                                             length), FALSE, FALSE)

    # also add the unused single units
    if(nrow(single.units[!single.units$combination%in%rs.test$combination,])>0){
      rs.test = rbind(single.units[!single.units$combination%in%rs.test$combination,], rs.test)
    }

    rownames(rs.test) = rs.test$combination

    # create an object with the observed event sizes
    event.sizes = Table(sapply(elements.test, FUN = length))
    max.event.size = max(rowsums(data))

    # function for the bootstrap, to be used in parallel lapply, or
    # in standard lapply loop
    # creates the probabilities of each element combination for random
    # selections of the null data set
    boot_foo <- function(x) {
      elements.boot <- elements.null[random.level.null %in% unique(sample(x = rl.null.ratio$subj, #select which events to take data from
                                                                          replace = TRUE,
                                                                          prob = rl.null.ratio$llh))]
      rs.boot <- rules_foo(elements = elements.boot, maxlen = combination.size) # create probabilities for random dataset
      boot.probability <- rs.boot$observed.probability[match(rs.test$combination, rs.boot$combination)] # order to match real data
      boot.probability[is.na(boot.probability)] <- 0
      boot.count <- rs.boot$count[match(rs.test$combination, rs.boot$combination)]
      boot.count[is.na(boot.count)] <- 0
      event.sizes.boot <- Table(sapply(elements.boot, FUN = length)) # create information for event sizes as well
      xx <- data.frame(combination.size = 0:max.event.size,
                       observed.probability = 0)
      xx$observed.probability[match(names(event.sizes.boot), xx$combination.size)] <- event.sizes.boot / sum(event.sizes.boot, na.rm = TRUE)
      return(list(boot.probability = boot.probability,
           boot.event.sizes = xx$observed.probability,
           boot.count = boot.count))
    }


    if (use_parallel) {
      # run parallel loop
      # which type of parallel depends on parallel_safe
      # if on Mac or Linux, mclapply should work
      if (!(Sys.info()[['sysname']] == 'Windows') & .Platform$OS.type == "unix") {
        boot.values <- mclapply(1:ran.trials,
                                FUN = boot_foo,
                                mc.cores = n_cores)
      } else {
        # create cluster for parallelization
        mycluster <- makeCluster(n_cores, type = "PSOCK")
        # export the relevant information to each core
        clusterExport(cl = mycluster,
                      c("ran.trials",
                        "elements.null",
                        "max.event.size",
                        "rs.test",
                        "condition.x",
                        "rl.null.ratio",
                        "combination.size",
                        "random.level.null",
                        "rules_foo",
                        "comb_n",
                        "Table"),
                      envir = environment())
        registerDoParallel(mycluster)
        # run parallel loop
        boot.values <- parLapply(cl = mycluster, X = 1:ran.trials, fun = boot_foo)
        # stop cluster
        stopCluster(mycluster)
      }
    } else {
      # run plain loop
      boot.values <- lapply(1:ran.trials, function(x) boot_foo(x))
    }


    ##### take the calculated probabilities for the randomisations and use them to return pvalues, z values, specificity, and increase
    boot.probability = do.call(cbind, lapply(boot.values, function(x){x$boot.probability}))
    boot.count = do.call(cbind, lapply(boot.values, function(x){x$boot.count}))

    rs.test$expected.probability <- rowmeans(boot.probability) # average probability under null condition
    # calculate z:
    # comparing observed value for each element against the distribution of
    # expected values for that element
    rs.test$z <- (rs.test$observed.probability - rowmeans(boot.probability)) /
      apply(boot.probability, 1, sd)
    rs.test$z[is.infinite(rs.test$z)] <- 10

    # # right-tailed p
    # # also, for getting the p-value, I would consider the observed data as one
    # # bootstrap/randomization (hence p can never be 0 exactly)
    # rs.test$p_right <- rowmeans(cbind(boot.probability[, -ran.trials], rs.test$observed.probability) >= rs.test$observed.probability)

    # p-value: two-sided, testing how many of the permutation results for that
    # element are more extreme than the observed value
    # take the smaller of the two p-values (number of permutations with larger
    # and smaller values)
    pright <- rowmeans(boot.probability >= rs.test$observed.probability)
    pleft <- rowmeans(boot.probability <= rs.test$observed.probability)

    if(tail == 'two-tailed'){rs.test$pvalue <- apply(cbind(pright, pleft), 1, min)}
    if(tail == 'right'){rs.test$pvalue <- pright}
    if(tail == 'left'){rs.test$pvalue <- pleft}


    if(!is.null(duration)){rs.test$count = rs.test$count * min.duration}
    rs.test[sapply(rs.test, is.numeric)] = lapply(rs.test[sapply(rs.test, is.numeric)], round, 3)

    ### for specificity, determine how often the combination occurs across test and null condition and then divide observed count in test by the sum
    xx = rs.null$count[match(rs.test$combination, rs.null$combination)]
    xx[is.na(xx)] = 0
    rs.test$specificity = (rs.test$count/(nrow(data.test) + nrow(data.null))) / ((rs.test$count + xx)/(nrow(data.test) + nrow(data.null)))

    # create probability increase by comparing the observed probability with the
    # mean probability of the randomisation process
    rs.test$probability.increase <- rs.test$observed.probability / rowmeans(boot.probability)
    rs.test$probability.increase[is.infinite(rs.test$probability.increase)] <- 100

    rs.test <- rs.test[, c("combination",
                           "combination.size",
                           "count",
                           "observed.probability",
                           "expected.probability",
                           "z",
                           "pvalue",
                           "specificity",
                           "probability.increase")]
    boot.probability <- boot.probability[order(rs.test$combination.size, -1 * as.numeric(rs.test$count)),]
    rs.test <- rs.test[order(rs.test$combination.size, -1 * as.numeric(rs.test$count)),]

    ##### combination size information per event
    event.probability = do.call(cbind, lapply(boot.values, function(x){x$boot.event.sizes}))

    t.event.size = data.frame(combination.size = 0:(nrow(event.probability)-1), observed.probability = 0, expected.probability = 0)
    t.event.size$observed.probability[match(names(event.sizes), t.event.size$combination.size)] = event.sizes/sum(event.sizes)
    t.event.size$expected.probability = rowmeans(event.probability)
    t.event.size$z = as.numeric(lapply(1:nrow(event.probability),function(z){ # create z value by taking the observed value for each element and comparing it against the mean and standard devation of the same element for the permutations
      m=sum(event.probability[z,])/length(event.probability[z,])
      stan = sd(event.probability[z,])
      xx=(t.event.size$observed.probability[z] - m) / stan
      return(xx)
    }))
    t.event.size$z[is.infinite(t.event.size$z)]=10

    t.event.size$pvalue = as.numeric(lapply(1:nrow(event.probability),function(z){ # p-value: two-sided, testing how many of the permutation results for that element are more extreme than the observed value
      xx=min(mean(event.probability[z,]>=t.event.size$observed.probability[z], na.rm=T), mean(event.probability[z,]<=t.event.size$observed.probability[z], na.rm=T)) # take the smaller of the two p-values (number of permutations with larger and smaller values)
      return(xx)
    }))
    t.event.size[sapply(t.event.size, is.numeric)] <- lapply(t.event.size[sapply(t.event.size, is.numeric)], round, 3)
  }


  ###### the following calculations are done when there is no condition specified, meaning the observed probability across all cases is compared to a null model based on permutations maintaining the event size and element probability
  if (is.null(condition)) {

    # same as above, account for added duration data
    if(is.null(duration)){min.duration = 1}
    if(!is.null(duration)){
      min.duration = min(duration)
      duration = round(duration/min.duration, 0)
      data <- data[rep(1:nrow(data), times = duration), ]
    }

    condition.x=rep('all', nrow(data))

    ### create probabilities for test dataset
    elements.test = lapply(1:nrow(data), function(x){
      xx = colnames(data)[data[x,]==1]
    })
    rs.test <- rules_foo(elements = elements.test, maxlen = combination.size)
    rs.test$combination.size = unlist(lapply(strsplit(as.character(rs.test$combination), "_", fixed = T),
                                             length), FALSE, FALSE)

    # add single elements that are not represented in the test data
    single.units = do.call(rbind, lapply(colnames(data), function(x){
      yy = rs.test[1,]
      yy$observed.probability = 0
      yy$count = 0
      yy$combination.size = 1
      yy$combination = x
      return(yy)
    }))

    if(nrow(single.units[!single.units$combination%in%rs.test$combination,])>0){
      rs.test = rbind(single.units[!single.units$combination%in%rs.test$combination,], rs.test)
    }

    data = as.matrix(data)
    # add event size information
    event.sizes = Table(sapply(elements.test, FUN = length))
    max.event.size = max(rowsums(data))

    # randomization function to be used either in parallel or plain loop
    randomize_foo <- function(x) {
      # To establish the expected probabilities for the elements, the data is compared to permutations that keep the number of elements per row constant but allow for the element probability to vary
      xx <- randomizeMatrix(samp = data, null.model = 'richness', iterations = 100)

      elements.boot = lapply(1:nrow(xx), function(x){
        xx = colnames(data)[xx[x,]==1]
      })

      # create probabilities for only the single element combinations
      rs.boot.1 = rules_foo(elements = elements.boot, maxlen = 1)

      # for all other combinations, do permutations that keep the number of cases per row and per column the same
      xx <- randomizeMatrix(samp = data, null.model = "independentswap", iterations = 100)

      elements.boot = lapply(1:nrow(xx), function(x){
        xx = colnames(data)[xx[x,]==1]
      })

      # create overall random dataset
      rs.boot.all = rules_foo(elements = elements.boot, maxlen = combination.size)
      comb.size = unlist(lapply(strsplit(as.character(rs.boot.all$combination), "_", fixed = T),
                                                 length), FALSE, FALSE)
      rs.boot.all = rs.boot.all[comb.size > 1,]

      # combine the datasets
      rs.boot = rbind(rs.boot.1, rs.boot.all)

      boot.probability = rs.boot$observed.probability[match(rs.test$combination, rs.boot$combination)]
      boot.probability[is.na(boot.probability)]=0

      list(boot.probability = boot.probability)
    }


    if (use_parallel) {
      # run parallel loop
      # which type of parallel depends on parallel_safe
      # if on Mac or Linux, mclapply should work
      if (!Sys.info()[['sysname']] == 'Windows' & .Platform$OS.type == "unix") {
        boot.values <- mclapply(1:ran.trials,
                                FUN = randomize_foo,
                                mc.cores = n_cores)
      } else {
        # create cluster for parallelization
        mycluster <- makeCluster(spec = n_cores, type = "PSOCK")
        # export the relevant information to each core
        clusterExport(cl = mycluster,
                      c("ran.trials",
                        "elements.test",
                        "max.event.size",
                        "rs.test",
                        "condition.x",
                        "combination.size",
                        "rules_foo",
                        "comb_n",
                        "data",
                        "randomizeMatrix",
                        "comb_n",
                        "Table"),
                      envir = environment())
        registerDoParallel(mycluster)
        # run parallel loop
        boot.values <- parLapply(cl = mycluster, X = 1:ran.trials, fun = randomize_foo)
        # stop cluster
        stopCluster(mycluster)
      }
    } else {
      # run plain loop
      boot.values <- mclapply(mc.cores = 1, X = 1:ran.trials, FUN = randomize_foo)
    }

    ##### calculate difference between expected and observed probability as z value, p value, and probability increase
    boot.probability <- do.call(cbind,lapply(boot.values, function(x) x$boot.probability ))
    rs.test$expected.probability <- rowmeans(boot.probability)
    # calculate z:
    # comparing observed value for each element against the distribution of
    # expected values for that element
    rs.test$z <- (rs.test$observed.probability - rowmeans(boot.probability)) /
      apply(boot.probability, 1, sd)
    rs.test$z[is.infinite(rs.test$z)] <- 10

    # p-value: two-sided, testing how many of the permutation results for that
    # element are more extreme than the observed value
    # take the smaller of the two p-values (number of permutations with larger
    # and smaller values)
    pright <- rowmeans(boot.probability >= rs.test$observed.probability)
    pleft <- rowmeans(boot.probability <= rs.test$observed.probability)
    if(tail == 'two-tailed'){rs.test$pvalue <- apply(cbind(pright, pleft), 1, min)}
    if(tail == 'right'){rs.test$pvalue <- pright}
    if(tail == 'left'){rs.test$pvalue <- pleft}

    if(!is.null(duration)){rs.test$count = rs.test$count * min(duration)}
    rs.test[sapply(rs.test, is.numeric)] <- lapply(rs.test[sapply(rs.test, is.numeric)], round, 3)

    # create probability increase by comparing the observed probability with the
    # mean probability of the randomisation process
    rs.test$probability.increase <- rs.test$observed.probability / rowmeans(boot.probability)
    rs.test$probability.increase[is.infinite(rs.test$probability.increase)] <- 100

    rs.test <- rs.test[, c("combination",
                           "combination.size",
                           "count",
                           "observed.probability",
                           "expected.probability",
                           "z",
                           "pvalue",
                           "probability.increase")]
    boot.probability <- boot.probability[order(rs.test$combination.size, -1 * as.numeric(rs.test$count)),]
    rs.test <- rs.test[order(rs.test$combination.size, -1 * as.numeric(rs.test$count)),]

    ##### combination size information per event; shuffle so that the number of time each element appears is kept constant, but number of elements per row differs
    event.probability = do.call(cbind, lapply(1:ran.trials, function(x){
      xx=randomizeMatrix(samp = as.matrix(data), null.model = 'frequency', iterations = 100)
      event.sizes.boot = Table(rowsums(xx)[rowsums(xx)<=max.event.size])/nrow(xx)
      event.sizes.boot = event.sizes.boot[!is.na(event.sizes.boot)]
      cs = data.frame(combination.size = 0:max.event.size, observed.probability = 0)
      cs$observed.probability[match(names(event.sizes.boot), cs$combination.size)] = event.sizes.boot
      return(cs$observed.probability)
    }))

    t.event.size = data.frame(combination.size = 0:(nrow(event.probability)-1), observed.probability = 0, expected.probability = 0)
    t.event.size$observed.probability[match(names(event.sizes), t.event.size$combination.size)] = event.sizes/sum(event.sizes)
    t.event.size$expected.probability = rowmeans(event.probability)
    t.event.size$z = as.numeric(lapply(1:nrow(event.probability),function(z){ # create z value by taking the observed value for each element and comparing it against the mean and standard devation of the same element for the permutations
      m=mean(event.probability[z,])
      stan = sd(event.probability[z,])
      xx=(t.event.size$observed.probability[z] - m) / stan
      return(xx)
    }))
    t.event.size$z[is.infinite(t.event.size$z)]=10

    t.event.size$pvalue = as.numeric(lapply(1:nrow(event.probability),function(z){ # p-value: two-sided, testing how many of the permutation results for that element are more extreme than the observed value
      xx=min(mean(event.probability[z,]>=t.event.size$observed.probability[z], na.rm=T), mean(event.probability[z,]<=t.event.size$observed.probability[z], na.rm=T)) # take the smaller of the two p-values (number of permutations with larger and smaller values)
      return(xx)
    }))
    t.event.size[sapply(t.event.size, is.numeric)] <- lapply(t.event.size[sapply(t.event.size, is.numeric)], round, 3)
  }

  # # arules works with so-called 'apriori' objects. In contrast to the probabilities used here, it works with conditional probabilities of all combinations. Really useful for lots of further things
  # test.rules = apriori(as(elements.test, 'transactions'), parameter = list(supp=1/nrow(data), conf=1/nrow(data), maxlen=max(rowsums(data))), control = list(verbose = FALSE))

  # summaries for the object
  rs.test = data.frame(lapply(rs.test, function(y) if(is.numeric(y)) round(y, 2) else y))
  t.event.size = data.frame(lapply(t.event.size, function(y) if(is.numeric(y)) round(y, 2) else y))
  used.parameters <- list(test.condition = test.condition,
                          null.condition = null.condition)
  used.data <- list(data = data,
                    condition = condition,
                    random.level = random.level,
                    control = control,
                    random.probability = boot.probability)
  event.size.information <- list(total.event.sizes = t.event.size)

  list(result = rs.test,
       used.parameters = used.parameters,
       used.data = used.data,
       event.size.information = event.size.information)
}
